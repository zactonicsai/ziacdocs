import path from "path";
import { explainTerraformResource, explainGitlabJob, explainArchitecture } from "./explain.js";

function rel(repoRoot, file) {
  return path.relative(repoRoot, file).replaceAll("\\", "/");
}

function mdEscape(s) {
  return String(s ?? "").replaceAll("\r", "");
}

function codeBlock(lang, content) {
  return `\n\`\`\`${lang}\n${mdEscape(content)}\n\`\`\`\n`;
}

export function renderMarkdownBundle({ repoRoot, terraform, gitlab, catalogs }) {
  const docs = [];

  // 1) Terraform doc
  const tfDoc = renderTerraformDoc({ repoRoot, terraform, catalogs });
  docs.push({ filename: "TERRAFORM.md", content: tfDoc });

  // 2) GitLab doc
  const glDoc = gitlab
    ? renderGitlabDoc({ repoRoot, gitlab, catalogs })
    : `# GitLab CI\n\nNo \`.gitlab-ci.yml\` found.\n`;
  docs.push({ filename: "GITLAB_CI.md", content: glDoc });

  // 3) Architecture/Security overview (from catalogs)
  const archDoc = renderArchitectureDoc({ catalogs });
  docs.push({ filename: "ARCHITECTURE_SECURITY.md", content: archDoc });

  const index = `# Documentation Index

- [Terraform Infrastructure](./TERRAFORM.md)
- [GitLab CI Pipeline](./GITLAB_CI.md)
- [Architecture & Security Notes](./ARCHITECTURE_SECURITY.md)

Generated by **iac-docgen**.
`;

  return { docs, index };
}

function renderTerraformDoc({ repoRoot, terraform, catalogs }) {
  const lines = [];
  lines.push(`# Terraform Infrastructure Documentation`);
  lines.push(``);
  lines.push(`## Files discovered`);
  for (const f of terraform.files) lines.push(`- \`${rel(repoRoot, f)}\``);

  lines.push(``);
  lines.push(`## High-level intent`);
  lines.push(
    `This section explains what the Terraform configuration is building and how it is wired together, ` +
    `with extra emphasis on **security, authentication/authorization, and network segmentation**.`
  );

  // Modules
  lines.push(``);
  lines.push(`## Modules`);
  if (!terraform.modules.length) {
    lines.push(`No Terraform modules detected.`);
  } else {
    for (const m of terraform.modules) {
      lines.push(`### \`module.${m.name}\``);
      lines.push(`- Defined in: \`${rel(repoRoot, m.file)}\``);
      lines.push(`- Source: \`${m.body?.source ?? "unknown"}\``);
      if (m.body?.version) lines.push(`- Version: \`${m.body.version}\``);
      lines.push(``);
    }
  }

  // Variables
  lines.push(`## Variables`);
  if (!terraform.variables.length) {
    lines.push(`No variables detected.`);
  } else {
    for (const v of terraform.variables) {
      const b = v.body || {};
      lines.push(`### \`${v.name}\``);
      lines.push(`- Defined in: \`${rel(repoRoot, v.file)}\``);
      if (b.type) lines.push(`- Type: \`${JSON.stringify(b.type)}\``);
      if (b.description) lines.push(`- Description: ${b.description}`);
      if (b.default !== undefined) lines.push(`- Default: \`${JSON.stringify(b.default)}\``);
      lines.push(``);
    }
  }

  // Resources
  lines.push(`## Resources`);
  if (!terraform.resources.length) {
    lines.push(`No resources detected.`);
  } else {
    // group by category then type
    const grouped = new Map();
    for (const r of terraform.resources) {
      const e = explainTerraformResource(r, catalogs);
      const key = `${e.category}::${r.type}`;
      if (!grouped.has(key)) grouped.set(key, { category: e.category, type: r.type, items: [] });
      grouped.get(key).items.push({ r, e });
    }

    const sortedKeys = [...grouped.keys()].sort();
    for (const key of sortedKeys) {
      const g = grouped.get(key);
      lines.push(`### ${g.category}: \`${g.type}\``);
      const catEntry = catalogs.aws?.resourceTypes?.[g.type];
      if (catEntry?.summary) lines.push(`**What this is:** ${catEntry.summary}`);
      if (catEntry?.keyConcerns?.length) {
        lines.push(`**Key concerns:** ${catEntry.keyConcerns.map(x => `\`${x}\``).join(", ")}`);
      }
      lines.push(``);

      for (const { r, e } of g.items) {
        lines.push(`#### \`${r.type}.${r.name}\``);
        lines.push(`- File: \`${rel(repoRoot, r.file)}\``);
        lines.push(`- Purpose: ${e.summary}`);
        if (e.notes.length) {
          lines.push(`- Notable configuration:`);
          for (const n of e.notes) lines.push(`  - ${n}`);
        }

        // include a small snippet of the raw body keys for transparency
        const keys = Object.keys(r.body || {}).slice(0, 12);
        if (keys.length) lines.push(`- Config keys (partial): ${keys.map(k => `\`${k}\``).join(", ")}`);
        lines.push(``);
      }
    }
  }

  // Outputs
  lines.push(`## Outputs`);
  if (!terraform.outputs.length) {
    lines.push(`No outputs detected.`);
  } else {
    for (const o of terraform.outputs) {
      lines.push(`### \`${o.name}\``);
      lines.push(`- Defined in: \`${rel(repoRoot, o.file)}\``);
      if (o.body?.description) lines.push(`- Description: ${o.body.description}`);
      if (o.body?.value) lines.push(`- Value expression present (not evaluated).`);
      lines.push(``);
    }
  }

  // Security checklist
  lines.push(`## Security & segmentation checklist (opinionated)`);
  lines.push(`- Prefer **private subnets** for app + data; only expose an ALB/API gateway publicly.`);
  lines.push(`- Avoid SSH/RDP from \`0.0.0.0/0\`. Use SSM Session Manager or a bastion with strict allowlists.`);
  lines.push(`- Enable **VPC Flow Logs** and **CloudTrail**; centralize logs.`);
  lines.push(`- Encrypt data at rest (KMS) and in transit (TLS).`);
  lines.push(`- Use Secrets Manager/SSM for secrets; do not commit credentials.`);
  lines.push(`- Minimize security group egress; prefer explicit allowlists for sensitive tiers.`);
  lines.push(``);

  return lines.join("\n");
}

function renderGitlabDoc({ repoRoot, gitlab, catalogs }) {
  const lines = [];
  lines.push(`# GitLab CI Pipeline Documentation`);
  lines.push(``);
  lines.push(`- File: \`${rel(repoRoot, gitlab.file)}\``);

  // Keywords explanations
  lines.push(``);
  lines.push(`## Key pipeline concepts`);
  for (const [k, v] of Object.entries(catalogs.gitlab?.keywords || {})) {
    lines.push(`- **${k}**: ${v}`);
  }

  lines.push(``);
  lines.push(`## Stages`);
  if (gitlab.stages?.length) {
    lines.push(gitlab.stages.map(s => `- \`${s}\``).join("\n"));
  } else {
    lines.push(`No explicit stages found (GitLab will use defaults if jobs define stages).`);
  }

  lines.push(``);
  lines.push(`## Variables`);
  const vars = gitlab.variables || {};
  const varKeys = Object.keys(vars);
  if (!varKeys.length) lines.push(`No global variables declared.`);
  else {
    for (const k of varKeys.sort()) {
      const v = vars[k];
      const display = typeof v === "string" ? v : JSON.stringify(v);
      lines.push(`- \`${k}\`: \`${display}\``);
    }
  }

  lines.push(``);
  lines.push(`## Jobs`);
  if (!gitlab.jobs.length) {
    lines.push(`No jobs detected.`);
  } else {
    // group by stage
    const stageMap = new Map();
    for (const job of gitlab.jobs) {
      const info = explainGitlabJob(job, catalogs);
      const stage = info.stage || "test";
      if (!stageMap.has(stage)) stageMap.set(stage, []);
      stageMap.get(stage).push({ job, info });
    }

    for (const stage of [...stageMap.keys()].sort()) {
      lines.push(`### Stage: \`${stage}\``);
      for (const { job, info } of stageMap.get(stage)) {
        lines.push(`#### \`${job.name}\``);
        lines.push(`- Tags: ${info.tags}`);
        lines.push(`- Uses rules: ${info.rules}`);
        lines.push(`- Publishes artifacts: ${info.artifacts}`);

        const script = Array.isArray(job.body?.script) ? job.body.script.join("\n") : (job.body?.script || "");
        if (script) {
          lines.push(``);
          lines.push(`**Script**:`);
          lines.push(codeBlock("bash", script).trimEnd());
        }

        if (info.hints?.length) {
          lines.push(`**Security notes / recommendations**:`);
          for (const h of info.hints) lines.push(`- ${h}`);
        }
        lines.push(``);
      }
    }
  }

  lines.push(`## Secure full-stack CI guidance (recommended)`);
  lines.push(`- Add SAST + dependency scanning (e.g., Semgrep, Trivy, OWASP Dependency-Check).`);
  lines.push(`- Add secrets scanning (e.g., gitleaks).`);
  lines.push(`- Add IaC scanning for Terraform (e.g., tfsec/checkov).`);
  lines.push(`- Gate deploy jobs to protected branches/tags and require approvals.`);
  lines.push(`- Use OIDC to cloud provider for CI auth (avoid long-lived AWS keys).`);
  lines.push(``);

  return lines.join("\n");
}

function renderArchitectureDoc({ catalogs }) {
  const lines = [];
  const arch = explainArchitecture(catalogs);

  lines.push(`# Architecture & Security Notes`);
  lines.push(``);
  lines.push(`## Network segmentation`);
  if (arch.segmentation) {
    lines.push(`**Summary:** ${arch.segmentation.summary}`);
    lines.push(``);
    for (const d of arch.segmentation.details || []) lines.push(`- ${d}`);
  } else {
    lines.push(`No segmentation catalog entry found.`);
  }

  lines.push(``);
  lines.push(`## Authentication & Authorization`);
  if (arch.auth) {
    lines.push(`**Summary:** ${arch.auth.summary}`);
    lines.push(``);
    for (const d of arch.auth.details || []) lines.push(`- ${d}`);
  } else {
    lines.push(`No auth catalog entry found.`);
  }

  lines.push(``);
  lines.push(`## Java API notes (Spring Boot)`);
  const java = catalogs.java?.concepts?.spring_security;
  if (java) {
    lines.push(`**Summary:** ${java.summary}`);
    lines.push(``);
    for (const d of java.details || []) lines.push(`- ${d}`);
  }

  lines.push(``);
  lines.push(`## React SPA notes`);
  const react = catalogs.react?.concepts?.spa_auth;
  if (react) {
    lines.push(`**Summary:** ${react.summary}`);
    lines.push(``);
    for (const d of react.details || []) lines.push(`- ${d}`);
  }

  return lines.join("\n");
}
